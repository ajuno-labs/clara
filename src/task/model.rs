use chrono::{DateTime, Local, TimeZone};
use rusqlite::types::{FromSql, FromSqlResult, ToSql, ToSqlOutput, ValueRef};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::fmt;

#[derive(Debug)]
pub enum Status {
    Todo,
    InProgress,
    Done,
}

#[derive(Debug)]
pub enum Priority {
    Low,
    Medium,
    High,
    Urgent,
}

impl fmt::Display for Status {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Status::Todo => write!(f, "todo"),
            Status::InProgress => write!(f, "doing"),
            Status::Done => write!(f, "done"),
        }
    }
}

impl Status {
    pub fn from_string(s: &str) -> Self {
        match s {
            "todo" => Status::Todo,
            "doing" => Status::InProgress,
            "done" => Status::Done,
            _ => Status::Todo,
        }
    }
}

impl fmt::Display for Priority {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Priority::Low => write!(f, "low"),
            Priority::Medium => write!(f, "medium"),
            Priority::High => write!(f, "high"),
            Priority::Urgent => write!(f, "urgent"),
        }
    }
}

impl Priority {
    pub fn from_string(s: &str) -> Self {
        match s {
            "low" => Priority::Low,
            "medium" => Priority::Medium,
            "high" => Priority::High,
            "urgent" => Priority::Urgent,
            _ => Priority::Medium,
        }
    }
}

impl ToSql for Status {
    fn to_sql(&self) -> rusqlite::Result<ToSqlOutput<'_>> {
        Ok(ToSqlOutput::from(self.to_string()))
    }
}

impl FromSql for Status {
    fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
        Ok(Status::from_string(value.as_str()?))
    }
}

impl ToSql for Priority {
    fn to_sql(&self) -> rusqlite::Result<ToSqlOutput<'_>> {
        Ok(ToSqlOutput::from(self.to_string()))
    }
}

impl FromSql for Priority {
    fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
        Ok(Priority::from_string(value.as_str()?))
    }
}

#[derive(Debug)]
pub struct Task {
    pub id: u32,
    pub title: String,
    pub status: Status,
    pub tags: Vec<String>,
    pub priority: Priority,
    pub due_date: Option<i64>,
    pub created_at: i64,
    pub updated_at: i64,
    pub completed_at: Option<i64>,
    pub parent_id: Option<u32>,
    pub project_id: Option<u32>,
    pub extras: Option<Value>,
}

impl fmt::Display for Task {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Task ID: {}, Title: {}, Status: {}, Priority: {}, Created: {}",
            self.id, self.title, self.status, self.priority, self.created_at_datetime()
        )?;

        if let Some(parent_id) = self.parent_id {
            write!(f, ", Parent: #{}", parent_id)?;
        }

        if let Some(project_id) = self.project_id {
            write!(f, ", Project: #{}", project_id)?;
        }

        if !self.tags.is_empty() {
            write!(f, ", Tags: [{}]", self.tags.join(", "))?;
        }

        if let Some(due_date) = self.due_date_datetime() {
            write!(f, ", Due: {}", due_date)?;
        }

        Ok(())
    }
}

#[derive(Serialize, Deserialize)]
pub struct TaskDraft {
    pub title: String,
    pub status: String,
    pub tags: Vec<String>,
    pub priority: String,
    pub due_date: Option<i64>,
    pub parent_id: Option<u32>,
    pub project_id: Option<u32>,
    pub extras: Option<Value>,
}

impl TaskDraft {
    pub fn new() -> Self {
        TaskDraft {
            title: String::new(),
            status: String::from("todo"),
            tags: Vec::new(),
            priority: String::from("medium"),
            due_date: None,
            parent_id: None,
            project_id: None,
            extras: None,
        }
    }

    pub fn to_task(self) -> Result<Task, String> {
        if self.title.trim().is_empty() {
            return Err("Task title cannot be empty".to_string());
        }

        let status = match self.status.to_lowercase().as_str() {
            "todo" => Status::Todo,
            "doing" | "in_progress" => Status::InProgress,
            "done" => Status::Done,
            _ => return Err("Invalid status. Use: todo, doing, or done".to_string()),
        };

        let priority = Priority::from_string(&self.priority);

        let now = Local::now().timestamp();

        Ok(Task {
            id: 0, // Will be auto-generated by DB
            title: self.title.trim().to_string(),
            status,
            tags: self.tags,
            priority,
            due_date: self.due_date,
            created_at: now,
            updated_at: now,
            completed_at: None,
            parent_id: self.parent_id,
            project_id: self.project_id,
            extras: self.extras,
        })
    }

    pub fn to_toml(&self) -> Result<String, toml::ser::Error> {
        toml::to_string_pretty(self)
    }

    pub fn from_toml(toml: &str) -> Result<Self, toml::de::Error> {
        toml::from_str(toml)
    }
}

impl Task {
    pub fn created_at_datetime(&self) -> DateTime<Local> {
        Local.timestamp_opt(self.created_at, 0).unwrap()
    }
    
    pub fn updated_at_datetime(&self) -> DateTime<Local> {
        Local.timestamp_opt(self.updated_at, 0).unwrap()
    }
    
    pub fn due_date_datetime(&self) -> Option<DateTime<Local>> {
        self.due_date.map(|ts| Local.timestamp_opt(ts, 0).unwrap())
    }
    
    pub fn completed_at_datetime(&self) -> Option<DateTime<Local>> {
        self.completed_at.map(|ts| Local.timestamp_opt(ts, 0).unwrap())
    }

    pub fn to_draft(&self) -> TaskDraft {
        TaskDraft {
            title: self.title.clone(),
            status: self.status.to_string(),
            tags: self.tags.clone(),
            priority: self.priority.to_string(),
            due_date: self.due_date,
            parent_id: self.parent_id,
            project_id: self.project_id,
            extras: self.extras.clone(),
        }
    }
}
